<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PayoutCalculator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">poker-engine</a> &gt; <a href="index.source.html" class="el_package">de.simonaltschaeffl.poker.service</a> &gt; <span class="el_source">PayoutCalculator.java</span></div><h1>PayoutCalculator.java</h1><pre class="source lang-java linenums">package de.simonaltschaeffl.poker.service;

import de.simonaltschaeffl.poker.model.Card;
import de.simonaltschaeffl.poker.model.HandResult;
import de.simonaltschaeffl.poker.model.Player;
import de.simonaltschaeffl.poker.model.PlayerStatus;
import de.simonaltschaeffl.poker.model.Pot;

import de.simonaltschaeffl.poker.api.GameEventListener;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Calculates the payouts for each player at the end of a round (showdown).
 * It evaluates hand strengths and distributes the pot correctly,
 * including logic for side pots when players go all-in with different amounts.
 */
public class PayoutCalculator {

    private final HandEvaluator handEvaluator;
    private final RakeStrategy rakeStrategy;
    private final List&lt;GameEventListener&gt; listeners;

    /**
     * Constructs a PayoutCalculator with the given HandEvaluator and RakeStrategy.
     *
     * @param handEvaluator the evaluator used to determine the strength of players'
     *                      hands
     * @param rakeStrategy  the strategy for deducting house commission
     * @param listeners     list of game event listeners
     */
<span class="fc" id="L36">    public PayoutCalculator(HandEvaluator handEvaluator, RakeStrategy rakeStrategy, List&lt;GameEventListener&gt; listeners) {</span>
<span class="fc" id="L37">        this.handEvaluator = handEvaluator;</span>
<span class="fc" id="L38">        this.rakeStrategy = rakeStrategy;</span>
<span class="fc" id="L39">        this.listeners = listeners;</span>
<span class="fc" id="L40">    }</span>

    // Constructor for backward compatibility in tests
    public PayoutCalculator(HandEvaluator handEvaluator) {
<span class="nc" id="L44">        this(handEvaluator, new NoRakeStrategy(), new ArrayList&lt;&gt;());</span>
<span class="nc" id="L45">    }</span>

<span class="fc" id="L47">    public record ShowdownResult(List&lt;Player&gt; winners, Map&lt;String, Integer&gt; payouts) {</span>
    }

    /**
     * Calculates the winners and their respective payouts given the players, the
     * board, and the pot.
     *
     * @param allPlayers the list of all players in the game (including active and
     *                   folded)
     * @param board      the community cards on the table
     * @param pot        the current pot with the contributions by each player
     * @return a ShowdownResult containing the winning players and their payout
     *         amounts
     */
    public ShowdownResult calculate(List&lt;Player&gt; allPlayers, List&lt;Card&gt; board, Pot pot) {
        // --- 0. Collect Rake ---
<span class="fc" id="L63">        int totalPotSize = pot.getTotal();</span>
<span class="fc" id="L64">        int rakeAmount = rakeStrategy.calculateRake(totalPotSize);</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">        if (rakeAmount &gt; 0) {</span>
<span class="nc" id="L66">            pot.deductRake(rakeAmount);</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">            for (GameEventListener listener : listeners) {</span>
<span class="nc" id="L68">                listener.onRakeCollected(rakeAmount);</span>
<span class="nc" id="L69">            }</span>
        }

        // 1. Filter Showdown Players
<span class="fc" id="L73">        List&lt;Player&gt; showdownPlayers = allPlayers.stream()</span>
<span class="pc bpc" id="L74" title="2 of 4 branches missed.">                .filter(p -&gt; p.getStatus() != PlayerStatus.FOLDED &amp;&amp; p.getStatus() != PlayerStatus.LEFT</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">                        &amp;&amp; p.getStatus() != PlayerStatus.SITTING_OUT)</span>
<span class="fc" id="L76">                .collect(Collectors.toList());</span>

        // 2. Evaluate all hands
<span class="fc" id="L79">        record PlayerHand(Player player, HandResult hand) {</span>
        }
        // Use parallel streams to speed up CPU-intensive hand evaluation.
<span class="fc" id="L82">        List&lt;PlayerHand&gt; results = showdownPlayers.parallelStream()</span>
<span class="fc" id="L83">                .map(p -&gt; new PlayerHand(p, handEvaluator.evaluate(p.getHoleCards(), board)))</span>
<span class="fc" id="L84">                .collect(Collectors.toCollection(ArrayList::new));</span>

        // 3. Group by Strength (Highest first) -&gt; Tiers
<span class="fc" id="L87">        results.sort((a, b) -&gt; b.hand.compareTo(a.hand)); // Winner first</span>

        // Group tied players
<span class="fc" id="L90">        List&lt;List&lt;PlayerHand&gt;&gt; tiers = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (!results.isEmpty()) {</span>
<span class="fc" id="L92">            List&lt;PlayerHand&gt; currentTier = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L93">            currentTier.add(results.get(0));</span>
<span class="fc" id="L94">            tiers.add(currentTier);</span>

<span class="fc bfc" id="L96" title="All 2 branches covered.">            for (int i = 1; i &lt; results.size(); i++) {</span>
<span class="fc" id="L97">                PlayerHand current = results.get(i);</span>
<span class="fc" id="L98">                PlayerHand prev = results.get(i - 1);</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">                if (current.hand.compareTo(prev.hand) == 0) {</span>
<span class="fc" id="L100">                    currentTier.add(current);</span>
                } else {
<span class="fc" id="L102">                    currentTier = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L103">                    currentTier.add(current);</span>
<span class="fc" id="L104">                    tiers.add(currentTier);</span>
                }
            }
        }

        // 4. Distribute Chips
<span class="fc" id="L110">        Map&lt;String, Integer&gt; payouts = new HashMap&lt;&gt;();</span>
<span class="fc" id="L111">        Map&lt;String, Integer&gt; contributions = pot.getContributions();</span>

        // Extract and sort unique bet sizes to calculate pot distribution in O(N) time.
<span class="fc" id="L114">        List&lt;Integer&gt; uniqueAmounts = contributions.values().stream()</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                .filter(v -&gt; v &gt; 0)</span>
<span class="fc" id="L116">                .distinct()</span>
<span class="fc" id="L117">                .sorted()</span>
<span class="fc" id="L118">                .collect(Collectors.toList());</span>

<span class="fc" id="L120">        int previouslyDeducted = 0;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        for (int amount : uniqueAmounts) {</span>
<span class="fc" id="L122">            int sliceAmount = amount - previouslyDeducted;</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">            if (sliceAmount &lt;= 0)</span>
<span class="nc" id="L124">                continue;</span>

<span class="fc" id="L126">            int potSlice = 0;</span>
<span class="fc" id="L127">            List&lt;String&gt; involvedIds = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">            for (Map.Entry&lt;String, Integer&gt; entry : contributions.entrySet()) {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">                if (entry.getValue() &gt;= amount) {</span>
<span class="fc" id="L131">                    potSlice += sliceAmount;</span>
<span class="fc" id="L132">                    involvedIds.add(entry.getKey());</span>
                }
<span class="fc" id="L134">            }</span>

<span class="fc" id="L136">            previouslyDeducted = amount;</span>

            // Determine winners for this slice
<span class="fc" id="L139">            List&lt;Player&gt; sliceWinners = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">            for (List&lt;PlayerHand&gt; tier : tiers) {</span>
<span class="fc" id="L141">                List&lt;Player&gt; winnersInTier = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">                for (PlayerHand ph : tier) {</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">                    if (involvedIds.contains(ph.player.getId())) {</span>
<span class="fc" id="L144">                        winnersInTier.add(ph.player);</span>
                    }
<span class="fc" id="L146">                }</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">                if (!winnersInTier.isEmpty()) {</span>
<span class="fc" id="L148">                    sliceWinners.addAll(winnersInTier);</span>
<span class="fc" id="L149">                    break;</span>
                }
<span class="fc" id="L151">            }</span>

<span class="pc bpc" id="L153" title="1 of 2 branches missed.">            if (!sliceWinners.isEmpty()) {</span>
<span class="fc" id="L154">                int share = potSlice / sliceWinners.size();</span>
<span class="fc" id="L155">                int remainder = potSlice % sliceWinners.size();</span>

<span class="fc bfc" id="L157" title="All 2 branches covered.">                for (Player winner : sliceWinners) {</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">                    int winAmount = share + (remainder &gt; 0 ? 1 : 0);</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">                    if (remainder &gt; 0)</span>
<span class="nc" id="L160">                        remainder--;</span>
<span class="fc" id="L161">                    payouts.merge(winner.getId(), winAmount, Integer::sum);</span>
<span class="fc" id="L162">                }</span>
            }
<span class="fc" id="L164">        }</span>

        // 5. Build Result
<span class="fc" id="L167">        List&lt;Player&gt; winners = results.stream()</span>
<span class="fc" id="L168">                .filter(ph -&gt; payouts.containsKey(ph.player.getId()))</span>
<span class="fc" id="L169">                .map(ph -&gt; ph.player)</span>
<span class="fc" id="L170">                .distinct()</span>
<span class="fc" id="L171">                .toList();</span>

<span class="fc" id="L173">        return new ShowdownResult(winners, payouts);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>